### 5.1 非访问控制修饰符
#### 5.1.1 static
    简单的来说,static修饰的静态方法,静态类,是不能够直接调用,非静态方法,非静态类的;如果想要调用就要进行相关的实例化操作;static修饰的方法和属性,是可以直接使用类名调用的;但是内部类不允许有static存在,所以内部类必须要实例化.将内部类看作是方法.
    类方法调用非静态的内部类,相当于调用实例方法:必须要实例化外部类,实例化完后再实例化内部类
    类方法调用静态的内部类,相当于调用类方法:(不必实例化外部类)实例化内部类;
    实例方法调用非静态的内部类,相当于调用实例方法: (不必实例化外部类)实例化内部类;
    实例方法调用静态的内部类,相当于调用实例方法:(不必实例化外部类)实例化内部类;




* [静态类](../Chapter03-Java类中的元素/page01Java中的类/page1.3静态内部类)
* [静态方法](../Chapter03-Java类中的元素/page03构造方法)
* [静态代码块](../Chapter03-Java类中的元素/Chapter03-Java类中的元素)
* [静态变量](../Chapter03-Java类中的元素/Chapter03-Java类中的元素/page04变量)


#### 5.1.2 final

* 与static一起创建常量
* 父类中的 final 方法可以被子类继承,但是不能被子类重写.


#### 5.1.3 synchronized
* synchronized 关键字声明的方法同一时间只能被一个线程访问.
* synchronized 修饰符可以应用于四个访问修饰符.

#### 5.1.4 transient
* 序列化的对象包含被 transient 修饰的实例变量时,java 虚拟机(JVM)跳过该特定的变量.
* 该修饰符包含在定义变量的语句中,用来预处理类和变量的数据类型.

#### 5.1.5 volatile 
* volatile 修饰的成员变量在每次被线程访问时,都强制从共享内存中重新读取该成员变量的值.而且，当成员变量发生变化时,会强制线程将变化值回写到共享内存.这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值.
* 一个 volatile 对象引用可能是 null.

#### 5.1.6 abstract 
* 修饰抽象类:
    - 抽象类不能用来实例化对象,声明抽象类的唯一目的是为了将来对该类进行扩充.
    - 一个类不能同时被abstract和final修饰.
    - 抽象类可以包含抽象方法和非抽象方法,但是非抽象类不能含有抽象方法;
* 修饰抽象方法:
    - 抽象方法是一种没有任何实现的方法,该方法的的具体实现由子类提供.
    - 抽象方法不能被声明成 final 和 static.
    - 任何继承抽象类的子类必须实现父类的所有抽象方法,除非该子类也是抽象类.

#### 5.1.8 extends 类之间继承的关键字

#### 5.1.9 interface实现接口
**接口也是一种引用类型,可以等同看做类**
    
* 如何定义接口,语法:
    - [修饰符] interface 接口名{}
* 接口中只有常量+抽象方法
    - 接口中所有的元素都是public修饰的
    - 接口中常量的public static final可以省略
    - 接口中方法不能有方法体;
    - 接口中方法的public abstract可以省略

* 接口是一个特殊的抽象类,因为接口是完全抽象的.
* 接口中没有构造方法,无法被实例化.
* 接口和接口之间可以多继承.
* 一个类可以实现多个接口.(这里的 **实现**可以等同看做 **继承**)
* 一个非抽象的类实现接口，需要将接口中所有的方法 **实现/重写/覆盖**.

#### 5.1.10 implements 接口与接口,类与接口之间的实现的关键字(类与接口间的继承叫实现)

#### 5.1.11 this 在继承关系中区分父类与子类,使用this关键字指**父类**
* this是一个关键字,是一个引用,保存内存地址指向自身.
* this可以使用在实例方法中,也可以使用在构造方法中.
* this出现在实例方法中其实代表的是当前对象.
* this不能使用在静态方法中.
* this. 大部分情况下可以省略,
    - 但是用来区分局部变量和实例变量的时候不能省略.
* this() 这种语法只能出现在构造方法第一行,表示当前构造方法调用本类其他的构造方法,目的是代码复用.

#### 5.1.12 在继承关系中区分父类与子类,使用super关键字指**父类**
* super能出现在实例方法和构造方法中.
* super的语法是:"super.","super()"
* super不能使用在静态方法中.
* super. 大部分情况下是可以省略的.
* super.什么时候不能省略呢？
    - 父类和子类中有同名属性,同样的方法.
    - 在子类中访问父类的,super. 不能省略.
* super() 只能出现在构造方法第一行,通过当前的构造方法去调用"父类"中的构造方法,目的是：创建子类对象的时候,先初始化父类型特征.