### 7.1 非访问控制修饰符
#### 7.1.1 static


* static修饰类([静态类](../Chapter03-Java类中的元素/01Java中的类/01.3静态内部类));
* static修饰方法([静态方法](../Chapter03-Java类中的元素/03方法));
* static修饰的代码块([静态代码块](../Chapter03-Java类中的元素/02代码块));

  * 静态代码块在类加载时执行;
* static修饰的变量([静态变量](../Chapter03-Java类中的元素/04变量));

  * 静态变量在类加载时初始化;


#### 7.1.2 final

* final修饰类变量,为常量,只能赋一次值;
* final修饰的实例变量,必须初始化;
* final修饰类,无法被继承;
* final修饰方法,无法被覆盖;


#### 7.1.3 synchronized
* synchronized 关键字声明的方法同一时间只能被一个线程访问.

* synchronized 修饰符可以应用于四个访问修饰符.

* 使用方法:

  * ```Java
    //第一种：同步代码块
    //灵活
    synchronized(线程共享对象){
        //同步代码块;
    }
    ```

  * ```Java
    /*
    第二种：在实例方法上使用synchronized
    表示共享对象一定是this
    并且同步代码块是整个方法体。
    */
    ```

  * ```Java
    /*
    第三种：在静态方法上使用synchronized
    	表示找类锁。
    	类锁永远只有1把。
    	就算创建了100个对象，那类锁也只有一把。
    */
    
    ```

    

  * 

#### 7.1.4 transient
* [序列化](../Chapter16-序列化与反序列化/01序列化与反序列化)的对象包含被 transient 修饰的实例变量时,java 虚拟机(JVM)跳过该特定的变量;
* 该修饰符包含在定义变量的语句中,用来预处理类和变量的数据类型.

#### 7.1.5 volatile 
* volatile 修饰的成员变量在每次被线程访问时,都强制从共享内存中重新读取该成员变量的值.而且，当成员变量发生变化时,会强制线程将变化值回写到共享内存.这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值.
* 一个 volatile 对象引用可能是 null.

#### 7.1.6 abstract 
* 修饰抽象类
* 修饰抽象方法

    

#### 7.1.8 extends 

* 类与类之间继承的关键字

#### 7.1.9 interface

* 修饰接口

#### 7.1.10 implements 

* 接口与接口之间继承;
* 类与接口之间的实现的关键字;

#### 7.1.11 this 

* this是一个引用变量,存储在当前对象的堆内存中,保存内存地址指向对象自身;
* this可以使用在实例方法,构造方法中;
* this不能使用在静态方法中;
* this引用在区分同名局部变量和实例变量的时候不能省略;
* this 可以作为构造方法,只能出现在构造方法第一行,表示当前构造方法调用本类其他的构造方法,目的是**代码复用**;

#### 7.1.12 super

* 在继承关系中区分父类与子类,使用super关键字指**父类对象**

* super可以使用在实例方法,构造方法中;
* super不能使用在静态方法中;
* super引用在区分父类和子类同名属性方法的时候不能省略;
* super 可以作为构造方法.只能出现在构造方法第一行,表示当前的构造方法调用"父类"中的构造方法,目的是：创建子类对象的时候,先初始化父类特征.

#### 7.1.13 new 

* 实例对象的关键字

* 凡是使用new关键字,都存储在堆内存;